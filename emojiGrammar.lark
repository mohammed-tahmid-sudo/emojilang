stmt: (_simple_stmt | _compound_stmt)* NEWLINE

_simple_stmt: _small_stmt

_small_stmt: assignment_stmt | flow_stmt | print_stmt | declare_stmt

// assignment_stmt: name "=" exp
assignment_stmt: name "ğŸ˜Œ" exp

// declare_stmt: "decl" (_multipleassignment_stmt | name) ("," (_multipleassignment_stmt | name))*
declare_stmt: "ğŸ“¢" (_multipleassignment_stmt | name) ("ğŸ—¿" (_multipleassignment_stmt | name))*

flow_stmt: break_stmt | continue_stmt

// break_stmt: "break"
break_stmt: "â¸"


// continue_stmt: "continue"
continue_stmt: "â©"


// print_stmt: "print" "(" (ESCAPED_STRING | exp) ")" 
print_stmt: "ğŸ–¨" "ğŸ‘‰" (ESCAPED_STRING | exp) "ğŸ‘ˆ" 


_compound_stmt: if_stmt | while_stmt | for_stmt

if_stmt: EIF "ğŸ‘‰" exp "ğŸ‘ˆ" "ğŸ½" suite "ğŸ¥‚" (EELIF "ğŸ‘‰" exp "ğŸ‘ˆ"  "ğŸ½" suite "ğŸ¥‚")* (EELSE "ğŸ½" suite "ğŸ¥‚")?

// while_stmt: "while" "(" for_test ")" "{" suite "}"
while_stmt: "ğŸ’¿" "ğŸ‘‰" for_test "ğŸ‘ˆ" "ğŸ½" suite "ğŸ¥‚"


// for_stmt: "for" "(" for_decl ";" for_test";" for_updates ")" "{" suite "}"
for_stmt: "ğŸ“€" "ğŸ‘‰" for_decl "ğŸ‘„" for_test"ğŸ‘„" for_updates "ğŸ‘ˆ" "ğŸ½" suite "ğŸ¥‚"


for_decl: (declare_stmt | assignment_stmt)?

for_test: exp?

for_updates: _multipleassignment_stmt?

_multipleassignment_stmt: assignment_stmt ("ğŸ—¿" assignment_stmt)?

suite: (_simple_stmt | _compound_stmt)* NEWLINE




?castexpression: (_unaryoperator?)_argument

?multiplicativeexpression: castexpression ((EMULT|EDIVIDE|EMOD) castexpression)*

?additiveexpression: multiplicativeexpression ((EPLUS|EMINUS) multiplicativeexpression)*

?equalityexpression: additiveexpression ((EEQU|ENOTEQ|ELESS|EGREA|EGREAE|ELESSE) additiveexpression)*

?andexpression: equalityexpression ((EAND) equalityexpression)*

?exclusiveorexpression: andexpression ((EXOR) andexpression)*

?inclusiveorexpression: exclusiveorexpression ((EOR) exclusiveorexpression)*

?logicalandexpression: inclusiveorexpression ((ELAND) inclusiveorexpression)*

?logicalorexpression: logicalandexpression ((ELOR) logicalandexpression)*

exp: logicalorexpression






_unaryoperator: (ENOT|ECOMPLEMENT)

_argument: boolean | number | name|("ğŸ‘‰" exp "ğŸ‘ˆ")

boolean: ETRUE | EFALSE
name: /[a-zA-z_][a-zA-Z0-9_]*/

%import common.SIGNED_NUMBER
%import common.WS
%import common.NEWLINE
%import common.ESCAPED_STRING
number: SIGNED_NUMBER
// ETRUE: "true"
ETRUE: "âœ”"

// EFALSE: "false"
EFALSE: "âŒ"

// EIF: "if"
EIF: "ğŸš©"

// EELIF: "elif"
EELIF: "ğŸ³"

// EELSE: "else"
EELSE: "ğŸ"

// EPLUS: "+"
EPLUS: "â•"

// EMINUS: "-"
EMINUS: "â–"

// EMULT: "*"
EMULT: "âœ–"

// EDIVIDE: "/"
EDIVIDE: "â—"


// ELESS: "<"
ELESS: "ğŸ˜­"

// EGREA: ">"
EGREA: "ğŸ˜"

// EEQU: "=="
EEQU: "ğŸ˜ŒğŸ˜Œ"

// EGREAE: ">="
EGREAE: "ğŸ˜ğŸ˜Œ"

// ELESSE: "<="
ELESSE: "ğŸ˜­ğŸ˜Œ"

// ENOTEQ: "!="
ENOTEQ: "â—ğŸ˜Œ"

//EAND: "&"
EAND: "âš›"

// EOR: "|"
EOR: "â˜¯"

// EXOR: "xor"|"^"
EXOR: "âš“"

// ENOT: "not"|"!"
ENOT: "â—"

EIN: "in"|"<-"
ENOTIN: "not in"|"<->"

// EMOD: "%"| "mod"
EMOD: "ğŸ“"

// ELOR: "||" | "or"
ELOR: "ğŸ˜‡"

// ELAND: "&&" | "and"
ELAND: "ğŸ˜ "

// ECOMPLEMENT: "~"
ECOMPLEMENT: "ã€°"


COMMENT: "ğŸ’©" /[^\n]/*


%ignore WS
%ignore COMMENT